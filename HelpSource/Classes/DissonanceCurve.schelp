CLASS:: DissonanceCurve
summary:: Analyzes timbres in order to create tunings
categories:: Tuning>TuningLib
related::  Classes/Tuning, Classes/Scale, Classes/Spectrum, http://eceserv0.ece.wisc.edu/~sethares/consemi.html

DESCRIPTION::

Uses Bill Seathares' Dissoncance Curve algorithm in order to compute tunings for a given timbre.


CLASSMETHODS::

METHOD:: new
Create a new curve based on arrays of data. This would mostly be used for additive synthesis.

argument:: freqs
An array of signficant frequencies of a timbre.

argument:: amps
An array of amplitudes for the given frequencies.

argument:: highInterval
The largest interval to compute in cents. For octave-based systems, you would usually use 1200. Default value is 1902.



METHOD:: fm
Create a curve based on the timbre of a given FM specification

argument:: carrier
The carrier frequency in Hz

argument:: modulator
The modulation frequency in Hz

argument:: depth
The depth (or delta range) of the modulator, in Hz

argument:: highInterval
 The largest interval to compute in cents. For octave-based systems, you would usually use 1200.

discussion::
	ex:
code::
(
	SynthDef("fm", {arg out, amp, carrier, modulator, depth;

		var sin;

		sin = SinOsc.ar(SinOsc.ar(modulator, 0, depth, carrier));
		Out.ar(out, sin * amp);
	}).add;
)
(
	var carrier, modulator, depth, curve, scale;

	carrier = 440;
	modulator = 600;
	depth = 100;

	curve = DissonanceCurve.fm(carrier, modulator, depth, 1202);
	scale = curve.scale;

)
::


METHOD:: fft
Create a curve based on the timbre of a given FFT buffer. THIS IS VERY SLOW and uses a lot of system resources

argument:: buffer
An FFT Buffer

argument:: size
The size of the Bufer in Frames

argument:: cutoff
The lower cutoff amplitude for a bin. Defaults to -60 dB

argument:: highInterval
The largest interval to compute in cents. For octave-based systems, you would usually use 1200.

argument:: action
A function to be evaluated once computing the curve is complete.


METHOD:: spectrum
Create a curve based on a link::Classes/Spectrum::

argument:: spectrum
a link::Classes/Spectrum::

argument:: highInterval
The largest interval to compute in cents. For octave-based systems, you would usually use 1200.



INSTANCEMETHODS::




METHOD:: tuning
Returns a link::Classes/Tuning:: based on the minima of the Dissonance Curve


METHOD:: scale
Returns a link::Classes/Scale:: in which the link::Classes/Tuning:: is the minima of the curve.

argument:: size
The number of degrees of the scale. For size n, it pickes the n most consonant degrees. Defaults to inf, which makes a scale degree for every degree of the Tuning.


METHOD:: plot
Plot the DissonanceCurve


METHOD:: digestibleTuning
Deprecated. Use justTuning



METHOD:: justTuning
Returns a link::Classes/Tuning:: Related to Sethares' algorithm, but calculated using a just tuning. This does a comparison of every partial at every tuning, but instead of looking at Plomp and Levit's ideas of local consonance, it compares the ratio relationships between the partials.  The numerator and denominator of this ratio is summed and then multiplied by the amplitude of the quieter partial.

		This algorythm just gives a list of the relative dissonance at all possible tunings. To figure out scale degrees, the most consonant tuning is picked from it's neighbors, given the window size.

		The tuning generated by this way and by the Sethares / Plomp and Levit algorithms may have nothing to do with each other.

argument:: window
The idealized step size, in cents. To do normal-ish semitones, this would be set to 100

returns:: a link::Classes/Tuning::



METHOD:: digestibleScale
Deprecated. Use justScale



METHOD:: justScale
Returns a link::Classes/Scale:: based on the justTuning.

argument:: window
The window size used to compute the justTuning

argument:: size
The number of degrees of the scale. For size n, it pickes the n most consonant degrees. Defaults to inf, which makes a Scale degree for every degree of the link::Classes/Tuning::.

returns:: a link::Classes/Scale::



METHOD:: limitedJustTuning
Uses the same calculation for dissonance as in justTuning, but picks scale degrees based on a given limit. Neither the numerator, nor the denominator may be greater than the limit.  The higher the given limit, the more the resultant tuning will be based on the timbre. The lower the limit, the more it will resemble normal, non-timbral just intonation.

		The tuning generated by this way and by the Sethares / Plomp and Levit algorithms may have nothing to do with each other.

argument:: limit
The largest allowed numerator or denominator. The higher this number, the greater the relationship between the scale and the timbre.

argument:: size
The number of ratios present in the tuning

returns:: a link::Classes/Tuning::

discussion::
It it necessary to limit by size because the dissonance curve contains ALL of the just tunings. Returning all tunings under the limit would just return a normal lattice. By including a size, we can limit the resultant tuning to the most timbrally-consonant steps.


METHOD:: limitedJustScale
Returns a link::Classes/Scale:: based on the limitedJustTuning.

argument:: limit
The largest allowed numerator or denominator used in computing the tuning

argument:: tuningSize
The number of ratios present in the tuning.

argument:: scaleSize
The numner of ratios present in the scale. If this is smaller than the number present in the tuning, it picks the most consonant steps.

returns:: a link::Classes/Scale::

discussion::
code::
(
var diss, scale;

// generate a 5 step scale, picking the 5 most consonant steps from the just dissonance curve,
// but only of those items under a a 21-limit.
diss = DissonanceCurve.fm(440, 650, 355.2, 1202);
scale = diss.limitedJustScale(21, 5);
diss.postJust;
)
::



METHOD:: postJust
Posts the ratios for the just tuning.
You must compute the scale first, via either of the two just methods

discussion::
code::
(
d = DissonanceCurve.fm(440, 600, 100, 1202);
d.justScale(100, 8);
d.postJust;
)
::
code::
(
d = DissonanceCurve.fm(440, 600, 100, 1202);
d.limitedJustScale(19, 11, 8);
d.postJust;
)
::

METHOD:: +
Adds two DiscconanceCurves together in a meaningful way. This would be useful to figure out a scale that works for two different timbres.
argument:: other
a Spectrum or a DissonanceCurve

returns:: a new DissonanceCurve


EXAMPLES::

Plot a curve:
code::
(
	d = DissonanceCurve.fm(1563, 560, 1200, 2400);
	d.plot;
)
::

Get a scale:
code::
(

	d = DissonanceCurve.fm(100, 200, 300, 1200);
	t = d.justTuning(100);
	t.cents.postln;
)
::

To use with a Pbind, let's make a synthdef that uses some of the keywords from event, specifically freq and octave.
code::
(
SynthDef("fm", {| out = 0, amp = 0.2, midinote=1, octave = 5, carrier, modulator, depth,
	dur = 1, detune = 0|

	var carrierOsc, modulation, env, degree, ratio;


	// adjust the octave. This assumes the fregencies we give for analysis generate a tone in the octave around middle C
	degree = midinote - 60;
	degree = degree + (12 * (octave - 5));

	// now compute a ratio
	ratio = degree.midiratio;

	// multiple the ratio by all of the FM values
	carrier = (carrier * ratio) + detune; // Pbinds sometimes use a detune value
	modulator = modulator * ratio;
	depth = depth * ratio;

	env = EnvGen.kr(Env.sine(dur, 1), doneAction:2);

	modulation = SinOsc.ar(modulator, 0, depth);
	carrierOsc = SinOsc.ar(carrier+ modulation, 0, env);

	Out.ar(out, carrierOsc.dup* amp);

}).add;
)
::
Our Pbind is very standard:
code::
(
var carrier, modulator, depth, scale;

carrier = 440;
modulator = 650;
depth = 355.2;

// generate a 5 step scale, picking the 5 most consonant steps from the dissonance curve
scale = DissonanceCurve.fm(carrier, modulator, depth, 1202).scale(5);

Pbind(
	\instrument, \fm,
	\scale, scale,
	\degree, Pwhite(0, scale.size), // use scale.size as a limit in case the curve generates fewer than 5 steps
	\carrier, carrier,
	\modulator, modulator,
	\depth, depth
).play;
)
::
The pbind will generate a midinote based on the degree chosen and the scale. This will be a floating point number. When we use this number in the synthDef, it will give us a useful ratio and generate the correct notes.
