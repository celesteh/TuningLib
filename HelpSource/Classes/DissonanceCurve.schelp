CLASS:: DissonanceCurve
summary:: Analyzes timbres in order to create tunings
categories:: Tuning>TuningLib
related::  Tuning, Scale, http://eceserv0.ece.wisc.edu/~sethares/consemi.html

DESCRIPTION::

Uses Bill Seathares' Dissoncance Curve algorithm in order to compute tunings for a given timbre.


CLASSMETHODS::

METHOD:: new
Create a new curve based on arrays of data. This would mostly be used for additive synthesis.

argument:: freqs
An array of signficant frequencies of a timbre.

argument:: amps
An array of amplitudes for the given frequencies.

argument:: highInterval
The largest interval to compute in cents. For octave-based systems, you would usually use 1200. Default value is 1902.



METHOD:: fm
Create a curve based on the timbre of a given FM specification

argument:: carrier
The carrier frequency in Hz

argument:: modulator
The modulation frequency in Hz

argument:: depth
The depth (or delta range) of the modulator, in Hz

argument:: highInterval
 The largest interval to compute in cents. For octave-based systems, you would usually use 1200.

discussion::
	ex:
code::
(
	SynthDef("fm", {arg out, amp, carrier, modulator, depth;

		var sin;

		sin = SinOsc.ar(SinOsc.ar(modulator, 0, depth, carrier));
		Out.ar(out, sin * amp);
	}).add;
)
(
	var carrier, modulator, depth, curve, scale;

	carrier = 440;
	modulator = 600;
	depth = 100;

	curve = DissonanceCurve.fm(carrier, modulator, depth, 1202);
	scale = curve.scale;

)
::


METHOD:: fft
Create a curve based on the timbre of a given FFT buffer. THIS IS VERY SLOW and uses a lot of system resources

argument:: buffer
An FFT Buffer

argument:: size
The size of the Bufer in Frames

argument:: cutoff
The lower cutoff amplitude for a bin. Defaults to -60 dB

argument:: highInterval
The largest interval to compute in cents. For octave-based systems, you would usually use 1200.

argument:: action
A function to be evaluated once computing the curve is complete.


METHOD:: spectrum
Create a curve based on a link::Classes/Spectrum::

argument:: spectrum
a link::Classes/Spectrum::

argument:: highInterval
The largest interval to compute in cents. For octave-based systems, you would usually use 1200.



INSTANCEMETHODS::




METHOD:: tuning
Returns a link::Classes/Tuning:: based on the minima of the Dissonance Curve


METHOD:: scale
Returns a link::Classes/Scale:: in which the link::Classes/Tuning:: is the minima of the curve.

argument:: size
The number of degrees of the scale. For size n, it pickes the n most consonant degrees. Defaults to inf, which makes a scale degree for every degree of the Tuning.


METHOD:: plot
Plot the DissonanceCurve


METHOD:: digestibleTuning
Deprecated. Use justTuning



METHOD:: justTuning
Returns a link::Classes/Tuning:: related to Sethares' algorithm, but calculated using a just tuning. Basically, it does a comparison of every partial at every tuning, but instead of looking at Plomp and Levit's ideas of local consonance, it compares the ratio relationships between the partials.  The numerator and denominator of this ratio is summed and then multiplied by the amplitude of the quieter partial.

		This algorythm just gives a list of the relative dissonance at all possible tunings. To figure out scale degrees, the most consonant tuning is picked from it's neighbors, given the window size.

		The tuning generated by this way and by the Sethares / Plomp and Levit algorithms may have nothing to do with each other.

argument:: window
The idealized step size, in cents. To do normal-ish semitones, this would be set to 100

returns:: a link::Classes/Tuning::



METHOD:: digestibleScale
Deprecated. Use justScale



METHOD:: justScale
Returns a link::Classes/Scale:: based on the justTuning.

argument:: window
The window size used to compute the justTuning

argument:: size
The number of degrees of the scale. For size n, it pickes the n most consonant degrees. Defaults to inf, which makes a Scale degree for every degree of the link::Classes/Tuning::.

returns:: a link::Classes/Scale::


METHOD:: postJust
Posts the ratios for the just scale.
You must compute the scale first;

discussion::
code::
(
d = DissonanceCurve.fm(440, 600, 100, 1202);
d.justScale(100);
d.postJust;
)
::


EXAMPLES::

Plot a curve:
code::
(
	d = DissonanceCurve.fm(1563, 560, 1200, 2400);
	d.plot;
)
::

Get a scale:
code::
(

	d = DissonanceCurve.fm(100, 200, 300, 1200);
	t = d.justTuning(100);
	t.cents.postln;
)
::

To use with a Pbind, let's make a synthdef that uses some of the keywords from event, specifically midinote and octave.
code::
(
SynthDef("fm", {| out = 0, amp = 0.2, midinote = 1, octave = 5, carrier, modulator, depth,
	dur = 1, detune = 0|

	var carrierOsc, modulation, env, degree, ratio;


	// adjust the octave. This assumes the fregencies we give for analysis generate a tone in the octave around middle C
	degree = midinote - 60;
	degree = degree + (12 * (octave - 5));

	// now compute a ratio
	ratio = degree.midiratio;

	// multiple the ratio by all of the FM values
	carrier = (carrier * ratio) + detune; // Pbinds sometimes use a detune value
	modulator = modulator * ratio;
	depth = depth * ratio;

	env = EnvGen.kr(Env.sine(dur, 1), doneAction:2);

	modulation = SinOsc.ar(modulator, 0, depth);
	carrierOsc = SinOsc.ar(carrier+ modulation, 0, env);

	Out.ar(out, carrierOsc.dup* amp);

}).add;
)
::
Our Pbind is very standard:
code::
(
var carrier, modulator, depth, scale;

carrier = 440;
modulator = 650;
depth = 355.2;

// generate a 5 step scale, picking the 5 most consonant steps from the dissonance curve
scale = DissonanceCurve.fm(carrier, modulator, depth, 1202).scale(5);

Pbind(
	\instrument, \fm,
	\scale, scale,
	\degree, Pwhite(0, scale.size), // use scale.size as a limit in case the curve generates fewer than 5 steps
	\carrier, carrier,
	\modulator, modulator,
	\depth, depth
).play;
)
::
The pbind will generate a midinote based on the degree chosen and the scale. This will be a floating point number. When we use this number in the synthDef, it will give us a useful ratio and generate the correct notes. 
